<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Metaverse Exhibition</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
        .chat-container {
            position: absolute;
            top: 10px;
            left: 10px;
            max-width: 300px;
            background-color: #f0f0f0;
            padding: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            border-radius: 5px;
            font-family: Arial, sans-serif;
        }
        .chat-messages {
            max-height: 200px;
            overflow-y: scroll;
            padding: 10px;
            background-color: #fff;
            border: 1px solid #ccc;
            border-radius: 5px;
        }
        .message {
            margin-bottom: 5px;
        }
        .message strong {
            color: #555;
        }
        .message-content {
            margin-left: 10px;
        }
        .message-form {
            margin-top: 10px;
        }
        .message-input {
            width: calc(100% - 70px);
            padding: 8px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 3px 0 0 3px;
        }
        .message-submit {
            width: 70px;
            padding: 8px;
            font-size: 14px;
            background-color: #4CAF50;
            color: #fff;
            border: none;
            border-radius: 0 3px 3px 0;
            cursor: pointer;
        }
        .message-submit:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>
    <div class="chat-container">
        <div class="chat-messages" id="chat-messages"></div>
        <form class="message-form" id="message-form">
            <input type="text" class="message-input" id="input-message" autocomplete="off" placeholder="Type your message...">
            <button type="submit" class="message-submit">Send</button>
        </form>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.socket.io/4.0.1/socket.io.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cannon/build/cannon.min.js"></script>
    <script>
        const socket = io('http://127.0.0.1:8081');

        let scene = new THREE.Scene();
        let camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        let renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        let light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(0, 10, 10).normalize();
        scene.add(light);

        let ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);

        scene.background = new THREE.Color(0xffffff); // 변경된 배경 색상

        // Cannon.js 월드 생성
        let world = new CANNON.World();
        world.gravity.set(0, -9.82, 0); // 중력 설정
        world.defaultContactMaterial.friction = 0.4; // 마찰력 설정
        world.defaultContactMaterial.restitution = 0.1; // 반발력 설정

        // 바닥 만들기 (Three.js + Cannon.js)
        let floorGeometry = new THREE.PlaneGeometry(200, 200);
        let floorMaterial = new THREE.MeshPhongMaterial({ color: 0x999999, side: THREE.DoubleSide });
        let floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);

        let floorShape = new CANNON.Plane();
        let floorBody = new CANNON.Body({ mass: 0 });
        floorBody.addShape(floorShape);
        floorBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
        world.addBody(floorBody);

        // 벽 만들기 (Three.js + Cannon.js)
        function createWall(width, height, depth, x, y, z) {
            let wallGeometry = new THREE.BoxGeometry(width, height, depth);
            let wallMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
            let wall = new THREE.Mesh(wallGeometry, wallMaterial);
            wall.position.set(x, y, z);
            scene.add(wall);

            let wallShape = new CANNON.Box(new CANNON.Vec3(width / 2, height / 2, depth / 2));
            let wallBody = new CANNON.Body({ mass: 0 });
            wallBody.addShape(wallShape);
            wallBody.position.set(x, y, z);
            world.addBody(wallBody);
        }

        // 전시회 벽 배치
        createWall(200, 10, 1, 0, 5, -100); // 뒤쪽 벽
        createWall(200, 10, 1, 0, 5, 100); // 앞쪽 벽
        createWall(1, 10, 200, -100, 5, 0); // 왼쪽 벽
        createWall(1, 10, 200, 100, 5, 0); // 오른쪽 벽

        // 캐릭터 및 사용자 관리
        let users = {};

        // 사용자 추가 함수
        function addUser(username, model, body) {
            model.scale.set(1, 1, 1);
            model.position.set(0, 1, 0);
            scene.add(model);

            let canvas = document.createElement('canvas');
            let context = canvas.getContext('2d');
            context.font = 'Bold 50px Arial';
            context.fillStyle = 'rgba(255,255,255,0.95)';
            context.fillText(username, 0, 50); // 이름 위치 조정

            let texture = new THREE.CanvasTexture(canvas);
            let spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            let sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(6, 3, 1); // 스프라이트 크기 조정
            sprite.position.set(0, 3, 0); // 스프라이트 위치 조정
        
            scene.add(sprite);

            users[username] = { model: model, sprite: sprite, body: body };
        }

        // 로그인한 사용자 이름 가져오기
        const username = localStorage.getItem('username');

        // 자신의 캐릭터 추가 (박스 모델)
        function addBoxModel(username) {
            let boxGeometry = new THREE.BoxGeometry(1, 1, 1);
            let boxMaterial = new THREE.MeshPhongMaterial({ color: 0x00ff00 });
            let box = new THREE.Mesh(boxGeometry, boxMaterial);

            let shape = new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5));
            let body = new CANNON.Body({ mass: 1, material: new CANNON.Material({ friction: 0.4, restitution: 0.1 }) });
            body.addShape(shape);
            body.position.set(0, 1, 0);
            world.addBody(body);

            addUser(username, box, body);
        }

        // 자신의 캐릭터 추가
        addBoxModel(username);

        // 현재 연결된 모든 사용자 추가
        socket.on('user_list', (usernames) => {
            usernames.forEach((user) => {
                if (user !== username) {
                    addBoxModel(user);
                }
            });
        });

        // 다른 사용자 추가
        socket.on('user_connected', (data) => {
            if (data.username !== username) {
                addBoxModel(data.username);
            }
        });

        // 다른 사용자가 떠날 때 처리
        socket.on('user_disconnected', (data) => {
           
                let user = users[data.username];
                if (user) {
                    scene.remove(user.model);
                    scene.remove(user.sprite);
                    world.remove(user.body);
                    delete users[data.username];
                }
            });

            // 다른 사용자의 위치 업데이트
            socket.on('update_position', (data) => {
                let user = users[data.username];
                if (user) {
                    user.model.position.set(data.position.x, data.position.y, data.position.z);
                    user.sprite.position.set(data.position.x, data.position.y + 2, data.position.z);
                    user.body.position.set(data.position.x, data.position.y, data.position.z);
                }
            });

            socket.on('connect', () => {
                socket.emit('add_user', { username: username });
            });

            // 카메라 위치 설정
            camera.position.set(0, 5, 15);

            // 키보드 입력 감지
            let keys = {};
            window.addEventListener('keydown', (event) => { keys[event.code] = true; });
            window.addEventListener('keyup', (event) => { keys[event.code] = false; });

            // 캐릭터 이동 함수
            function moveCharacter() {
                let user = users[username];
                let moved = false;
                const speed = 10; // 속도 값을 증가시킴

                user.body.velocity.set(0, 0, 0); // 기존 속도 초기화

                if (keys['ArrowUp']) {
                    user.body.velocity.z = -speed; // z 방향으로 이동
                    moved = true;
                }
                if (keys['ArrowDown']) {
                    user.body.velocity.z = speed; // z 방향으로 이동
                    moved = true;
                }
                if (keys['ArrowLeft']) {
                    user.body.velocity.x = -speed; // x 방향으로 이동
                    moved = true;
                }
                if (keys['ArrowRight']) {
                    user.body.velocity.x = speed; // x 방향으로 이동
                    moved = true;
                }

                // 스프라이트 위치 업데이트
                user.sprite.position.set(user.model.position.x, user.model.position.y + 2, user.model.position.z);

                // 카메라가 캐릭터를 따라가도록 설정
                camera.position.set(user.model.position.x, user.model.position.y + 5, user.model.position.z + 10);
                camera.lookAt(user.model.position);

                // 캐릭터가 움직였을 경우 서버에 위치 업데이트 이벤트 전송
                if (moved) {
                    socket.emit('update_position', {
                        username: username,
                        position: {
                            x: user.body.position.x,
                            y: user.body.position.y,
                            z: user.body.position.z
                        }
                    });
                }
            }

            // 애니메이션 루프
            function animate() {
                requestAnimationFrame(animate);
                moveCharacter();

                // Cannon.js 월드 업데이트
                world.step(1 / 60);

                // 모델 위치 업데이트
                for (let key in users) {
                    let user = users[key];
                    user.model.position.copy(user.body.position);
                }

                renderer.render(scene, camera);
            }

            // 창 크기 변경 시 카메라 비율 조정
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            animate();

            // 채팅 관련 코드 시작
            const chatForm = document.getElementById('message-form');
            const chatInput = document.getElementById('input-message');
            const chatMessages = document.getElementById('chat-messages');

            // 채팅 메시지 받기
            socket.on('chat_message', (data) => {
                appendMessage(data.username, data.message);
            });

            // 메시지 전송
            chatForm.addEventListener('submit', (event) => {
                event.preventDefault();
                const message = chatInput.value;
                if (message) {
                    socket.emit('send_message', { username: username, message: message });
                    appendMessage(username, message);
                    chatInput.value = '';
                }
            });

            // 메시지 추가
            function appendMessage(username, message) {
                const messageElement = document.createElement('div');
                messageElement.classList.add('message');
                messageElement.innerHTML = `<strong>${username}:</strong> <span class="message-content">${message}</span>`;
                chatMessages.appendChild(messageElement);
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }

         
// 문과 문의 physics body 정의
let door, doorBody;

// 부스 생성 함수
function createBooth(width, height, depth, x, y, z, texturePath, hasDoor = false) {
    const textureLoader = new THREE.TextureLoader();
    const boothGeometry = new THREE.BoxGeometry(width, height, depth);
    const boothMaterial = new THREE.MeshPhongMaterial({
        map: textureLoader.load(texturePath)
    });
    const booth = new THREE.Mesh(boothGeometry, boothMaterial);
    booth.position.set(x, y, z);
    scene.add(booth);

    // Cannon.js physics body 생성
    const boothShape = new CANNON.Box(new CANNON.Vec3(width / 2, height / 2, depth / 2));
    const boothBody = new CANNON.Body({ mass: 0 });
    boothBody.addShape(boothShape);
    boothBody.position.set(x, y, z);
    world.addBody(boothBody);

    // 부스 내부에 문 추가 여부 확인
    if (hasDoor) {
        const doorWidth = 2;
        const doorHeight = height;
        const doorDepth = 0.1;

        // 문의 geometry와 material 설정
        const doorGeometry = new THREE.BoxGeometry(doorWidth, doorHeight, doorDepth);
        const doorMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });
        door = new THREE.Mesh(doorGeometry, doorMaterial);

        // 문의 위치 설정 (부스 내부에 배치)
        door.position.set(0, 0, depth / 2 + doorDepth / 2); // 부스 내부 중앙에 문을 배치하도록 수정

        // Three.js scene에 문 추가
        booth.add(door);

        // Cannon.js physics body 생성
        const doorShape = new CANNON.Box(new CANNON.Vec3(doorWidth / 2, doorHeight / 2, doorDepth / 2));
        doorBody = new CANNON.Body({ mass: 0 });
        doorBody.addShape(doorShape);

        // 문의 위치 설정 (부스 내부에 배치)
        doorBody.position.set(x, y, z);
        doorBody.position.vadd(new CANNON.Vec3(0, 0, depth / 2 + doorDepth / 2), boothBody.position); // Cannon.js에서 부스 내부 위치에 문을 추가하도록 수정

        // 부스 내부에 문 physics body 추가
        world.addBody(doorBody);
    }

    // 문을 열고 닫을 수 있는 함수
    booth.openDoor = function() {
        if (door) door.visible = false; // 문을 열기 위해 문 객체를 보이지 않도록 설정
        if (doorBody) world.removeBody(doorBody); // Cannon.js에서 문 physics body 제거
    };

    booth.closeDoor = function() {
        if (door) door.visible = true; // 문을 닫기 위해 문 객체를 보이게 설정
        if (doorBody) world.addBody(doorBody); // Cannon.js에서 문 physics body 추가
    };

    return booth;
}



            // 부스 배치 함수
            function setupBooths() {
                const boothTextures = [
                    '../static/images/2145.jpg',
                    '../static/images/2145.jpg',
                    '../static/images/2145.jpg',
                    '../static/images/2145.jpg',
                    '../static/images/2145.jpg'
                ];
                const boothPositions = [
                    { x: 10, y: 2.5, z: 30 },
                    { x: -30, y: 2.5, z: 0 },
                    { x: 0, y: 2.5, z: 10 },
                    { x: 30, y: 2.5, z: -10 },
                    { x: 100, y: 2.5, z: 15 }
                ];

                for (let i = 0; i < boothPositions.length; i++) {
                    const booth = createBooth(10, 5, 10, boothPositions[i].x, boothPositions[i].y, boothPositions[i].z, boothTextures[i],true);
                    decorateBooth(booth);
                    booth.openDoor(); 
                }
            }

            // 부스 내부 장식 함수
            function decorateBooth(booth) {
                const itemGeometry = new THREE.BoxGeometry(2, 2, 2);
                const itemMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
                const item = new THREE.Mesh(itemGeometry, itemMaterial);
                item.position.set(0, 1, 0);
                booth.add(item);

              
            }

            // 부스 생성 및 장식 함수 호출
            setupBooths();
        </script>
    </body>
</html>
